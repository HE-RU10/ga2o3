#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar  4 15:32:36 2024

@author: jinxinjx
"""

import glob
import gzip
import numpy as np

class CELL:
    """
    """
    
    def __init__(self):
        
        self.element = {"H": 1}
        self.elementSequence = []
        
        self.xyz = np.empty([1,3])
        self.TotNum = 0
        self.boxsize_x, self.boxsize_y, self.boxsize_z = 2, 2, 2
        
        self.min_x, self.min_y = -1, -1
        
        self.centerFlag = 0
        
    def translate(self, x, y, z):
        """
        Translate the cell along three directions by distances x, y and z
        """
        
        if (x != 0):
            self.xyz[:, 0] += x
        if (y != 0):
            self.xyz[:, 1] += y
        if (z != 0):
            self.xyz[:, 2] += z
            
        self.centerFlag = 0
            
    def shrink(self, x, y, z):
        """
        Shrink / expand the cell along the three direction by factors of x, y and z
        """
        
        if (x != 1):
            self.xyz[:, 0] *= x
            self.boxsize_x *= x
        if (y != 1):
            self.xyz[:, 1] *= y
            self.boxsize_y *= y
        if (z != 1):
            self.xyz[:, 2] *= z
            self.boxsize_z *= z
            
        self.centerFlag = 0
            
    def centerOrigin(self):
        """
        Move the origin from the corner to the cell center
        """
        
        self.xyz[:, 0] -= (self.boxsize_x / 2)
        self.xyz[:, 1] -= (self.boxsize_y / 2)
        self.xyz[:, 2] -= (self.boxsize_z / 2)
        
        self.centerFlag = 1
        
    def periodicBC(self, x1, x2, y1, y2, z1, z2):
        """
        Perform a periodic boundary condtion on cells.
        The boundary limits: x1, x2, y1, y2, z1, z2
        
        (Note, the function can only handle atoms in the first neighbour cells)
        """
        
        limit_up = [x2, y2, z2]
        limit_down = [x1, y1, z1]
        move = [self.boxsize_x, self.boxsize_y, self.boxsize_z]
        
        for i in range(self.TotNum):
            for j in range(3):
                if self.xyz[i, j] >= limit_up[j]:
                    self.xyz[i, j] -= move[j]
                elif self.xyz[i, j] < limit_down[j]:
                    self.xyz[i, j] += move[j]
                else:
                    continue
        
    def write(self, locout):
        """
        Note: The cell origin may not be correct
        """
        
        with open(locout, 'w') as wt:
            wt.write('%d\n' % (self.TotNum))
            wt.write('Lattice=" %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f " '%(self.boxsize_x,0.0,0.0,0.0,self.boxsize_y,0.0,0.0,0.0,self.boxsize_z))
            wt.write('Origin=" %.5f %.5f %.5f "\n'%(-0.5*self.boxsize_x, -0.5*self.boxsize_y, -0.5*self.boxsize_z))
            for i in range(self.TotNum):
                wt.write('%s %.5f %.5f %.5f %s\n'%(self.element[self.elementSequence[i]], self.xyz[i,0],
                                                   self.xyz[i,1], self.xyz[i,2], self.elementSequence[i]))

def method1(target, angle, axs):
  """
  Rotate the target, method 1
  (Reference: A. Kelly, Crystallography and Crystal Defects, 2012)
  
  target: 3D vectors with the shape as 3 * m
  angle: rotation angle [degree]
  axs: [n1, n2, n3] is the rotation axis
  
  return: target after the rotation
  """
  
  angle = angle * np.pi / 180
  n1 = axs[0]
  n2 = axs[1]
  n3 = axs[2]
  
  R11 = np.cos(angle) + n1 * n1 * (1 - np.cos(angle) )
  R12 = n1 * n2 * (1 - np.cos(angle) ) - n3 * np.sin(angle)
  R13 = n3 * n1 * (1 - np.cos(angle) ) + n2 * np.sin(angle)
  
  R21 = n1 * n2 * (1 - np.cos(angle) ) + n3 * np.sin(angle)
  R22 = np.cos(angle) + n2 * n2 * (1 - np.cos(angle) )
  R23 = n2 * n3 * (1 - np.cos(angle) ) - n1 * np.sin(angle)
  
  R31 = n3 * n1 * (1 - np.cos(angle) ) - n2 * np.sin(angle)
  R32 = n2 * n3 * (1 - np.cos(angle) ) + n1 * np.sin(angle)
  R33 = np.cos(angle) + n3 * n3 * (1 - np.cos(angle) )
  
  RotMatrix = [[R11, R12, R13],\
               [R21, R22, R23],\
               [R31, R32, R33]]
  
  RotMatrix = np.array(RotMatrix)
  
  #For arrays in Python 3.5, @ is the matrix multiplication operator
  target_bis = RotMatrix @ target
  
  return(target_bis)

def readASE(inpath, elementID=None):
    """
    Read the cells generated by ASE
    inpath: path to the cell;
    elementID: if not none,
               only take atoms in the list of element IDs
    """
    
    print("Start to read ASE cell: %s\n" % inpath)
    
    coord = []
    eleSequence = []    
    
    if '.gz' in inpath:
        
        with gzip.open(inpath, 'rt') as op:
            
            lineCount = 0
            line_flag = 1e10
            
            for line in op:
                lineCount += 1
                
                #line_flag is the line number where 'Atoms' is, and is followed by coordinates
                if 'Atoms' in line:
                    line_flag = lineCount
                
                if lineCount == 3:
                    totNum = int(line.split()[0])
                    
                if lineCount > 3 and 'Atoms' not in line:
                    if 'xlo' in line:
                        linesplit = line.split()
                        boxsize_x = float(linesplit[1]) - float(linesplit[0])
                    if 'ylo' in line:
                         linesplit = line.split()
                         boxsize_y = float(linesplit[1]) - float(linesplit[0])
                    if 'zlo' in line:
                         linesplit = line.split()
                         boxsize_z = float(linesplit[1]) - float(linesplit[0])  
                         
                if lineCount >= (line_flag+2) and lineCount < (line_flag+2+totNum):
                    linesplit = line.split()
                    if elementID == None:
                        eleSequence.append(int(linesplit[1]))
                        coord.append([])
                        coord[-1].append(float(linesplit[2]))
                        coord[-1].append(float(linesplit[3]))
                        coord[-1].append(float(linesplit[4]))
                    else:
                        if int(linesplit[1]) in elementID:
                            eleSequence.append(int(linesplit[1]))
                            coord.append([])
                            coord[-1].append(float(linesplit[2]))
                            coord[-1].append(float(linesplit[3]))
                            coord[-1].append(float(linesplit[4]))
                    
                if 'Velocities' in line:
                    break
                
    else:
        
        with open(inpath, 'r') as op:
            
            lineCount = 0
            line_flag = 1e10
            
            for line in op:
                lineCount += 1
                
                #line_flag is the line number where 'Atoms' is, and is followed by coordinates
                if 'Atoms' in line:
                    line_flag = lineCount
                
                if lineCount == 3:
                    totNum = int(line.split()[0])
                    
                if lineCount > 3 and 'Atoms' not in line:
                    if 'xlo' in line:
                        linesplit = line.split()
                        boxsize_x = float(linesplit[1]) - float(linesplit[0])
                    if 'ylo' in line:
                         linesplit = line.split()
                         boxsize_y = float(linesplit[1]) - float(linesplit[0])
                    if 'zlo' in line:
                         linesplit = line.split()
                         boxsize_z = float(linesplit[1]) - float(linesplit[0])  
                         
                if lineCount >= (line_flag+2) and lineCount < (line_flag+2+totNum):
                    linesplit = line.split()
                    if elementID == None:
                        eleSequence.append(int(linesplit[1]))
                        coord.append([])
                        coord[-1].append(float(linesplit[2]))
                        coord[-1].append(float(linesplit[3]))
                        coord[-1].append(float(linesplit[4]))
                    else:
                        if int(linesplit[1]) in elementID:
                            eleSequence.append(int(linesplit[1]))
                            coord.append([])
                            coord[-1].append(float(linesplit[2]))
                            coord[-1].append(float(linesplit[3]))
                            coord[-1].append(float(linesplit[4]))
                    
                if 'Velocities' in line:
                    break
     
    coord = np.array(coord)
    eleSequence = np.array(eleSequence)
    
    if elementID == None:
        if len(coord) != totNum: 
            raise ValueError("The total number of atoms does not match the number of coordinates")
    else:
        totNum = len(coord)
    
    return(totNum, boxsize_x, boxsize_y, boxsize_z, coord, eleSequence)

#======================================================================================

loc_out = './Rotate'

#Get all the MD cells
file_name = []
for i in glob.glob('*.lastframe-*'):
    file_name.append(i)
    
#Read the cell, rotate and translate
for i in range(len(file_name)):
    
    #Read
    at1 = CELL()
    at1.TotNum, at1.boxsize_x, at1.boxsize_y, at1.boxsize_z, at1.xyz, at1.elementID = \
        readASE(file_name[i])
    
    #Rotation    
    rot_axis = [1, 0, 0]
    rot_ang = 90
    at1.xyz = np.transpose(method1(np.transpose(at1.xyz), rot_ang, rot_axis))
    
    #Translate
    at1.xyz[:,1] += at1.boxsize_z #Translate after rotation
    tmp_size = at1.boxsize_z
    at1.boxsize_z = at1.boxsize_y
    at1.boxsize_y = tmp_size
    at1.translate(-at1.boxsize_x/2, -at1.boxsize_y/2, -at1.boxsize_z/2)
    at1.periodicBC(-at1.boxsize_x/2, at1.boxsize_x/2, -at1.boxsize_y/2, at1.boxsize_y/2, -at1.boxsize_z/2, at1.boxsize_z/2) #Translate for origin
    
    # Get the list of elements names according to the element IDs
    at1.element = {"Ga1" : 1, "Ga2" : 2, "O1" : 3, "O2" : 4, "O3" : 5}
    at1. elementSequence = []   
    for j in range(len(at1.elementID)):
        for ename, IDs in at1.element.items():
            if IDs == at1.elementID[j]:
                at1.elementSequence.append(ename)

    #Write
    at1.write('%s/%s' % (loc_out, file_name[i]))
        
    
    
